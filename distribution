#!/usr/bin/perl

# distribution - creates histograms based on input
#
# Version 1.0
#
# Written by Tim Ellis of Palomino
# Copyright (c) 2012 by Tim Ellis
# Released under the terms of GNU GPLv2:
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, visit http://www.gnu.org/licenses/gpl-2.0.html in your
# web browser.
#
# If you're still living in the 1800's, you can instead write to:
#
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301, USA.

use warnings;
use strict;

# if your system is dying on this statement, it should be safe to simply comment
# it out. your timings with --verbose will be very course.
use Time::HiRes qw( time );

# for determining how long this program ran
my $startTime = time() * 1000;

# defaults - override with ~/.distributionrc some day
my $width = 80;
my $height = 25;
# character for ease of eye to scan left/right/up/down
my $histogramChar = "+";
my $tokenize = 0;
# by default, everything matches (nothing is stripped out)
my $matchRegexp = ".";
# status and summary statistics
my $verbose = 0;
# how often to give status if verbose
my $statInterval = 0.5;
# whether or not to parse input into bins
# (if data is pre-summarised and we're just presenting results)
my $graphValues = "";

# variables to support colourised output
my $colourisedOutput = 0;
my $regularColour = "";
my $keyColour = "";
my $countColour = "";
my $percentColour = "";
my $graphColour = "";

# process input arguments -- any arguments that aren't known switches
# are stuck onto @extraArgs - note that you can have one or two dashes
# before the option, and only need the first character. also options
# that take values and switches can be overloaded, so -c=o -c means
# use the o character and colourise the output. this can be confusing.
my @extraArgs;
foreach my $arg (@ARGV) {
	if ($arg =~ /^-+h(elp)*$/)               { doArgs(); exit 0; }
	elsif ($arg =~ /^-+w(idth)*=(.+)$/)      { $width = $2; }
	elsif ($arg =~ /^-+h(eight)*=(.+)$/)     { $height = $2; }
	elsif ($arg =~ /^-+g(raph)*=(.+)$/)      { $graphValues = $2; }
	elsif ($arg =~ /^-+g(raph)*$/)           { $graphValues = 'vk'; }
	elsif ($arg =~ /^-+c(har)*=(.+)$/)       { $histogramChar = $2; }
	elsif ($arg =~ /^-+c(olor)*$/)           { $colourisedOutput = 1; }
	elsif ($arg =~ /^-+t(okenize)*=(.+)$/)   { $tokenize = $2; }
	elsif ($arg =~ /^-+m(atch)*=(.+)$/)      { $matchRegexp = $2; }
	elsif ($arg =~ /^-+v(erbose)*$/)         { $verbose = 1; }
	else { push (@extraArgs, $arg); }
}

# variables to support colourised output
if ($colourisedOutput) {
	$regularColour = chr(27) . "[0m";
	$keyColour = chr(27) . "[0m";
	$countColour = chr(27) . "[32m";
	$percentColour = chr(27) . "[35m";
	$graphColour = chr(27) . "[34m";
}

# some useful substitutions for prettiness
if ($histogramChar eq "em") { $histogramChar = "—"; }
if ($histogramChar eq "me") { $histogramChar = "⋯"; }
if ($histogramChar eq "cp") { $histogramChar = "©"; }
if ($histogramChar eq "di") { $histogramChar = "♦"; }
if ($histogramChar eq "dt") { $histogramChar = "•"; }
if ($histogramChar eq "st") { $histogramChar = "★"; }
if ($histogramChar eq "sq") { $histogramChar = "□"; }
if ($histogramChar eq "tf") { $histogramChar = "∴"; }
if ($histogramChar eq "yy") { $histogramChar = "☯"; }
if ($histogramChar eq "pc") { $histogramChar = "☮"; }
if ($histogramChar eq "pr") { $histogramChar = "☠"; }

# some useful regexp replacements
if ($matchRegexp eq 'word') { $matchRegexp = '^[A-Z,a-z]+$'; }
if ($matchRegexp eq 'num')  { $matchRegexp = '^\d+$'; }
if ($tokenize eq 'word')    { $tokenize = '[^\w]'; }
if ($tokenize eq 'white')   { $tokenize = '\s'; }

# build the dict of input values
my $inLine;
my $nextStat = time() + $statInterval;
my $valuesDict;
my $totalValues = 0;
my $totalObjects = 0;

if ($graphValues) {
	# here is the case where we don't need to put the input into
	# bins and tally - the data is pre-tallied for us
	while ($inLine = <STDIN>) {
		chomp ($inLine);
		if ($graphValues eq 'vk') {
			if ($inLine =~ /^(\d+)\s+(.+)$/) {
				$valuesDict->{$2} = $1;
				$totalValues += $1;
				$totalObjects++;
			} else {
				print STDERR " E Input line malformed and discarded: $inLine\n";
			}
		} elsif ($graphValues eq 'kv') {
			if ($inLine =~ /^(.+?)\s+(\d+)$/) {
				$valuesDict->{$1} = $2;
				$totalValues += $2;
				$totalObjects++;
			} else {
				print STDERR " E Input line malformed and discarded: $inLine\n";
			}
		}
	}
} else {
	# read in lines and build hash object from it
	while ($inLine = <STDIN>) {
		chomp($inLine);
		if ($tokenize) {
			# in this case we break the line into tokens and tally them
			foreach my $lineToken (split (/$tokenize/, $inLine)) {
				$totalObjects++;
				if ($lineToken =~ /$matchRegexp/) {
					$valuesDict->{$lineToken}++;
					$totalValues++;
				}
			}
		} else {
			# in this case the entire line is the token to be tallied
			$totalObjects++;
			if ($inLine =~ /$matchRegexp/) {
				$valuesDict->{$inLine}++;
				$totalValues++;
			}
		}
		if ($verbose && time() > $nextStat) {
			print STDERR " + Objects Processed: $totalObjects...";
			$nextStat = time() + $statInterval;
		}
	}
	if ($verbose) { print STDERR " + Objects Processed: $totalObjects.   \n"; }
}

# the input may be empty. or we may have been too strict on the
# matching regexp passed in. either way, we were left with nothing.
if ($totalValues == 0) {
	if ($totalObjects > 0) {
		print STDERR "All input filtered! ";
	} else {
		print STDERR "No input! ";
	}
	print STDERR "No histogram for you.\n";
	exit 255;
}

# get the keys ordered - we'll only print the most common keys
my @sortedKeys = reverse sort { int($valuesDict->{$a}) <=> int($valuesDict->{$b}) } keys %{$valuesDict};

# if there aren't height # of distinct values, use less
my $totalKeys = scalar @sortedKeys;
if ($totalKeys < $height) { $height = $totalKeys; }

my $i;
my $j;
my $maxCount = $valuesDict->{$sortedKeys[0]};
my $keyText;
my $preBarText;
my $barWidth;
my $maxPreBarLen = 0;
my $maxKeyLen = 0;
# here is the complex part - read it carefully
for ($i = 0; $i < $height; $i++) {
	# print the i-most common key
	$keyText->[$i] = $sortedKeys[$i];
	# how many times this key occurred in the input
	my $count = $valuesDict->{$sortedKeys[$i]};
	# determine the bar width based on key occurence
	$barWidth->[$i] = $count / $maxCount;
	# determine the percent of key frequency
	my $percentile = $count / $totalValues * 100;
	# graph axis labels, really
	$preBarText->[$i] = sprintf ("%d %s(%3.02f%%)", $count, $percentColour, $percentile);
	# determine the widest bar's width and longest key name for
	# aligning the output
	if (length ($preBarText->[$i]) > $maxPreBarLen) { $maxPreBarLen = length ($preBarText->[$i]); }
	if (length ($sortedKeys[$i]) > $maxKeyLen) { $maxKeyLen = length ($sortedKeys[$i]); }
}

my $endTime = time() * 1000;
my $totalMillis = sprintf ("%.2f", ($endTime - $startTime));

if ($verbose) {
	print STDERR "tokens/lines examined: $totalObjects\n";
	print STDERR " tallied in histogram: $totalValues\n";
	print STDERR "    histogram entries: $totalKeys\n";
	print STDERR "              runtime: ${totalMillis}ms\n";;
}

# print a header with alignment from key names
print STDERR "Val";
for ($j = 4; $j <= $maxKeyLen; $j++) { print STDERR " "; }
print STDERR "|Ct (Pct)";
for ($j = 8; $j <= $maxPreBarLen; $j++) { print STDERR " "; }
print STDERR "Histogram";

# for some reason this leads to an extra blank line if you sort
# the colourised output
print "$keyColour\n";

# amount of other output reduces possible size of bar - alas
my $maxBarWidth = $width - $maxPreBarLen - $maxKeyLen - 4;

for ($i = 0; $i < $height; $i++) {
	print $keyText->[$i];
	print $regularColour;
	for ($j = length ($keyText->[$i]); $j < $maxKeyLen; $j++) { print " "; }
	print "|";
	print $countColour;
	print $preBarText->[$i];
	for ($j = length ($preBarText->[$i]); $j <= $maxPreBarLen; $j++) { print " "; }
	# print one too many bar characters so <1% gets a single bar character
	print $graphColour;
	for ($j = 0; $j <= int ($barWidth->[$i] * $maxBarWidth); $j++) { print $histogramChar; }
	# we do these antics of printing $keyColour on the line before the key
	# so that piping output to sort will work
	print "$keyColour\n";
}

# put the terminal back into a normal-colour mode
print $regularColour;

exit 0;


# ----------------------------------------------------------------- #
#                           subroutines
# ----------------------------------------------------------------- #

# usage
sub doArgs {
	print "\n";
	print "usage: <commandWithOutput> | $0\n";
	print "         [--width=<width>]\n";
	print "         [--height=<height>]\n";
	print "         [--color]\n";
	print "         [--tokenize=<tokenChar>]\n";
	print "         [--graph[=[kv|vk]]\n";
	print "         [--char=<barChars>|<substitutionString>]\n";
	print "         [--help][--verbose]\n";
	print "  --char=C       character(s) to use for histogram character, some substitutions follow:\n";
	print "        em       (—) Emdash\n";
	print "        me       (⋯) Mid-Elipses\n";
	print "        cp       (©) Copyright\n";
	print "        di       (♦) Diamond\n";
	print "        dt       (•) Dot\n";
	print "        st       (★) Star\n";
	print "        sq       (□) Square\n";
	print "        tf       (∴) Triforce\n";
	print "        yy       (☯) YinYang\n";
	print "        pc       (☮) Peace\n";
	print "        pr       (☠) Pirate\n";
	print "  --color        colourise the output\n";
	print "  --graph        input is already key/value pairs. vk is default:\n";
	print "        kv       input is ordered key then value\n";
	print "        vk       input is ordered value then key\n";
	print "  --height=N     height of histogram, headers non-inclusive. graphs this number of values\n";
	print "  --help         get help\n";
	print "  --match=RE     only match lines (or tokens) that match this regexp, some substitutions follow:\n";
	print "        word     ^[A-Z,a-z]+\$ - tokens/lines must be entirely alphabetic\n";
	print "        num      ^\\d+\$        - tokens/lines must be entirely numeric\n";
	print "  --tokenize=RE  split input on regexp RE and make histogram of all resulting tokens\n";
	print "        word     [^\\w] - split on non-word characters like colons, brackets, commas, etc\n";
	print "        white    \\s    - split on whitespace\n";
	print "  --width=N      width of the histogram report, N characters\n";
	print "  --verbose      be verbose\n";
	print "\n";
	print "You can use single-characters options, like so: -h=25 -w=20 -v. You must still include the =\n";
	print "\n";
	print "Samples:\n";
	print "  du -sb /etc/* | $0 --graph\n";
	print "  du -sk /etc/* | awk '{print \$2\" \"\$1}' | $0 --graph=kv\n";
	print "  zcat /var/log/syslog*gz | $0 --char=o --tokenize=white\n";
	print "  zcat /var/log/syslog*gz | awk '{print \$5}'  | $0 --t=word --m-word --h=15 --c=/\n";
	print "  zcat /var/log/syslog*gz | cut -c 1-9        | $0 --width=60 --height=10 --char=em\n";
	print "  find /etc -type f       | cut -c 6-         | $0 --tokenize=/ --w=90 --h=35 --c=dt\n";
	print "  cat /usr/share/dict/words | awk '{print length(\$1)}' | $0 --c=* --w=50 --h=10 | sort -n\n";
	print "\n";
}

